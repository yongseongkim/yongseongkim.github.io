<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">Synchronization Techniques in Game Development | yongseongkim&#x27;s blog</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://yongseongkim.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://yongseongkim.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://yongseongkim.github.io/blog/2022/03/10/game-synchronizations/"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Synchronization Techniques in Game Development | yongseongkim&#x27;s blog"><meta data-rh="true" name="description" content="모빌리티 플랫폼 &#x27;타다&#x27; 개발에서 탑승 플로우(호출 - 호출 중 - 매칭 - 탑승 - 탑승 완료)를 앱에서 잘 보여주는 것이 매우 중요합니다."><meta data-rh="true" property="og:description" content="모빌리티 플랫폼 &#x27;타다&#x27; 개발에서 탑승 플로우(호출 - 호출 중 - 매칭 - 탑승 - 탑승 완료)를 앱에서 잘 보여주는 것이 매우 중요합니다."><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2022-03-10T00:00:00.000Z"><meta data-rh="true" property="article:tag" content="game,synchronization"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://yongseongkim.github.io/blog/2022/03/10/game-synchronizations/"><link data-rh="true" rel="alternate" href="https://yongseongkim.github.io/blog/2022/03/10/game-synchronizations/" hreflang="en"><link data-rh="true" rel="alternate" href="https://yongseongkim.github.io/blog/2022/03/10/game-synchronizations/" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","@id":"https://yongseongkim.github.io/blog/2022/03/10/game-synchronizations","mainEntityOfPage":"https://yongseongkim.github.io/blog/2022/03/10/game-synchronizations","url":"https://yongseongkim.github.io/blog/2022/03/10/game-synchronizations","headline":"Synchronization Techniques in Game Development","name":"Synchronization Techniques in Game Development","description":"모빌리티 플랫폼 '타다' 개발에서 탑승 플로우(호출 - 호출 중 - 매칭 - 탑승 - 탑승 완료)를 앱에서 잘 보여주는 것이 매우 중요합니다.","datePublished":"2022-03-10T00:00:00.000Z","author":[],"keywords":[],"isPartOf":{"@type":"Blog","@id":"https://yongseongkim.github.io/blog","name":"Blog"}}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="yongseongkim&#39;s blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="yongseongkim&#39;s blog Atom Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TJY4YF1TRD"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TJY4YF1TRD",{anonymize_ip:!0})</script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.cc461cd2.css">
<script src="/assets/js/runtime~main.601c792b.js" defer="defer"></script>
<script src="/assets/js/main.bdd2de9a.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/img/logo.svg"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="yongseongkim&#x27;s blog" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="yongseongkim&#x27;s blog" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">yongseongkim&#x27;s blog</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog/">Blog</a><a class="navbar__item navbar__link" href="/blog/tags/">Tags</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><div role="group"><h3 class="yearGroupHeading_rMGB">2025</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2025/08/17/spring-transaction-template-understanding/">Spring JPA TransactionTemplate Internals</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2024</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2024/06/22/lotto-bot/">Auto Lotto Bot</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2022</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/2022/03/10/game-synchronizations/">Synchronization Techniques in Game Development</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2021</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2021/09/25/uilabel-alignment/">UILabel Alignment</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2021/06/25/how-to-open-app-by-url/">How To Open An App By URL</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2020</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2020/06/14/swift-memory-management/">Memory Management in Swift</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2020/05/26/swiftui-data-flow-patterns/">SwiftUI - Data Flow Patterns</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2020/05/25/swiftui-layout-system/">SwiftUI - Layout System</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2020/02/09/introduction-to-steganography/">Introduction to Steganography</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2019</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2019/02/02/alphago-zero/">AlphaGo Paper Review (2)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2019/01/19/alphago-lee/">AlphaGo Paper Review</a></li></ul></div></nav></aside><main class="col col--7"><article class=""><header><h1 class="title_f1Hy">Synchronization Techniques in Game Development</h1><div class="container_mt6G margin-vert--md"><time datetime="2022-03-10T00:00:00.000Z">March 10, 2022</time> · <!-- -->14 min read</div></header><div id="__blog-post-container" class="markdown"><p>모빌리티 플랫폼 &#x27;타다&#x27; 개발에서 탑승 플로우(호출 - 호출 중 - 매칭 - 탑승 - 탑승 완료)를 앱에서 잘 보여주는 것이 매우 중요합니다.
호출을 하고 있다가 시간 만료로 취소가 되거나 매칭이 되었지만 드라이버가 사정이 생겨 취소하는 경우 등 탑승자의 아무런 입력 없이도 앱에서 탑승 상태를 잘 나타내야 합니다.
서버에 탑승 상태를 모바일 앱에서 잘 보여주기 위한 방법들을 고민하다가 멀티플레이어 게임에서의 어떻게 다른 플레이어들과 동시간대에 있는 것처럼 동기화가 잘되는지가 궁금해졌습니다.
멀티플레이어 게임을 하다보면 다양한 플레이어들의 상호작용이 있는데 이걸 어떻게 끊김 없이 보여주고 있는지 궁금해져서 관련된 기술들을 찾아서 정리해봤습니다.</p>
<p>여러 사용자가 참여하는 게임에서 동기화 방식은 다양합니다.
발생한 입력을 모아 클라이언트가 시뮬레이션하거나 서버에서 입력을 모아 시뮬레이션 후 클라이언트에서는 해당 상태를 자연스럽게 보여줄 수 있습니다.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="lockstep">Lockstep<a href="#lockstep" class="hash-link" aria-label="Direct link to Lockstep" title="Direct link to Lockstep">​</a></h2>
<p><img decoding="async" loading="lazy" alt="lockstep-process" src="/assets/images/lockstep-process-967ce9196f15864dc7392ea3ebfd855d.png" width="773" height="588" class="img_ev3q">
출처: <a href="https://blog.naver.com/linegamedev/221061964789" target="_blank" rel="noopener noreferrer">멀티플레이 게임의 동기화 기법 시리즈 2편: 이벤트 동기화</a></p>
<p>Lockstep 은 라운드마다 서버가 플레이어들의 입력을 모아서 클라이언트들에 전송하여 시뮬레이션을 클라이언트에서 진행합니다.
일관성 유지를 위해 모든 단계를 맞춰가면서 진행됩니다.
하나의 라운드 내에서 모든 이벤트들에 순서가 매겨지게 되며, 예외가 발생하는 것을 미리 방지합니다.
가장 처리가 느린 클라이언트 위주로 진행되기 때문에 레이턴시가 큰 유저가 있으면 멈춤이 발생합니다.
참가자 수가 적은 RTS 에서 사용하고 참가자 수가 늘어날 수록 입력 패킷 도달 지연이 발생할 가능성이 큽니다.</p>
<p><img decoding="async" loading="lazy" alt="lockstep-fixed-time-interval" src="/assets/images/lockstep-fixed-time-interval-d3388a7e36f233c85199a87face64240.png" width="773" height="595" class="img_ev3q"></p>
<p>출처: <a href="https://blog.naver.com/linegamedev/221061964789" target="_blank" rel="noopener noreferrer">멀티플레이 게임의 동기화 기법 시리즈 2편: 이벤트 동기화</a></p>
<p>서로 다른 클라이언트 간 지연으로 피하기 위해 시간을 정해 라운드를 진행할 수도 있습니다.</p>
<p>아래 그림은 클라이언트에서 입력만을 교환해서 시뮬레이션하는 lockstep 에 대한 예시입니다.
서로의 상태를 hash value 로 항상 비교합니다.
주로 RTS 혹은 과거 AOS 게임에서 쓰는 방식입니다.</p>
<p><img decoding="async" loading="lazy" alt="lockstep-table-step1" src="/assets/images/lockstep-table-step1-7959f82a2a056459dbaa2186e654d489.png" width="1662" height="802" class="img_ev3q"></p>
<p>출처: <a href="https://youtu.be/j3eQNm-Wk04" target="_blank" rel="noopener noreferrer">[NDC] CAP 이론을 통한 네트워크 동기화 기법</a></p>
<p>1초에 20번 업데이트하는 게임에서 50ms 당 라운드를 가집니다.
각 클라이언트는 이벤트 큐가 존재하고 라운드마다 이벤트를 처리합니다.
네트워크 상황에 따라 이벤트를 처리하는 시점이 다를텐데 여기서 &#x27;나&#x27; 와 &#x27;상대2&#x27; 에 대한 이벤트를 받았지만 &#x27;상대1&#x27; 에 대한 이벤트는 받지 못한 상황입니다.</p>
<p><img decoding="async" loading="lazy" alt="lockstep-table-step2" src="/assets/images/lockstep-table-step2-7d7722739d42fe2bceb8f1e60c4c740b.png" width="1884" height="868" class="img_ev3q"></p>
<p>출처: <a href="https://youtu.be/j3eQNm-Wk04" target="_blank" rel="noopener noreferrer">[NDC] CAP 이론을 통한 네트워크 동기화 기법</a></p>
<p>&#x27;상대1&#x27; 의 이벤트까지 모이면 해당 라운드를 시뮬레이션해서 처리합니다.</p>
<p><img decoding="async" loading="lazy" alt="lockstep-table-step3" src="/assets/images/lockstep-table-step3-4f9e5496aa18c6033bfe9f783a184304.png" width="2338" height="864" class="img_ev3q"></p>
<p>출처: <a href="https://youtu.be/j3eQNm-Wk04" target="_blank" rel="noopener noreferrer">[NDC] CAP 이론을 통한 네트워크 동기화 기법</a></p>
<p>&#x27;나&#x27; 와 &#x27;상대2&#x27; 의 이벤트는 계속 전달되고 있지만 &#x27;상대1&#x27; 은 네트워크 불안정으로 인해 이벤트를 받지 못한다면 해당 라운드 처리가 불가합니다.</p>
<p>| 상대방을 기다리는 상황 | 기다리다 상대방을 내쫓은 상황 |
| <img decoding="async" loading="lazy" alt="lockstep-starcraft-wating-for-players" src="/assets/images/lockstep-starcraft-wating-for-players-popup-0ff45d976993c3febb63aed4f1f0ce82.jpg" width="601" height="448" class="img_ev3q"> | <img decoding="async" loading="lazy" alt="lockstep-starcraft-drop-player" src="/assets/images/lockstep-starcraft-drop-player-0d834b8d24e787f3d3a30c3f0e5f5514.png" width="640" height="480" class="img_ev3q"> |</p>
<p>출처: <a href="http://starcraft.burningblade.org/stories/index.html" target="_blank" rel="noopener noreferrer">Robocop&#x27;s Starcraft Page</a></p>
<p>게임 스타크래프트를 해봤으면 위와 같은 팝업들을 많이 보셨을 겁니다. 라운드 처리를 위해 상대방 이벤트를 기다리다가 쫓은 상황입니다.</p>
<p><img decoding="async" loading="lazy" alt="lockstep-starcraft-network-options" src="/assets/images/lockstep-starcraft-network-options-d7a557c91f17de7dd5d07c662b9198f3.png" width="265" height="313" class="img_ev3q"></p>
<p>출처: <a href="http://starcraft.burningblade.org/stories/index.html" target="_blank" rel="noopener noreferrer">Robocop&#x27;s Starcraft Page</a></p>
<p>위와 같은 상황처럼 lockstep 에서는 동기화 주기가 중요합니다.
스타크래프트에서는 위 이미지와 같은 네트워크 옵션 선택이 있었는데 low latency 는 자주 동기화 하겠다는 뜻입니다.
자주 동기화하면 플레이어가 빠른 반응을 느낄 수 있지만 한 플레이어라도 늦으면 바로 멈추는 상황이 생겨버립니다.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="authoritative-server">Authoritative Server<a href="#authoritative-server" class="hash-link" aria-label="Direct link to Authoritative Server" title="Direct link to Authoritative Server">​</a></h2>
<p>라운드를 가지는 lockstep 과 다르게 라운드 없이 모든 이벤트를 지속적으로 받아 서버가 판단하는 방식입니다.
클라이언트에서 발생하는 이벤트를 서버로 전달, 서버에서는 이벤트를 모아 시뮬레이션하여 상태 변화를 클라이언트로 보냅니다.
클라이언트는 과거의 서버 상태를 재생하는 형태입니다. 그래서 클라이언트마다 일관성이 안맞을 수 있습니다.</p>
<p><img decoding="async" loading="lazy" src="https://post-phinf.pstatic.net/MjAxNzEyMjRfMTY1/MDAxNTE0MDkyMzQ5MjA4._A49iM-itpHIoKJE_uJStJQ71lkJhJBMsXcwQoFHIUQg.SZw0b1lbLY0ceErbxejgJpHw684oLDFAKWOCYQ1ROh0g.GIF/honeycam_2017-12-22_18-57-33.gif?type=w1200" alt="배틀그라운드 트레이서 현상" class="img_ev3q"></p>
<p>출처: <a href="https://m.post.naver.com/viewer/postView.nhn?volumeNo=11513471&amp;memberNo=16036253" target="_blank" rel="noopener noreferrer">배틀그라운드 트레이서 현상</a></p>
<p>위 영상은 실제로 버그였지만 위 영상과 같이 클라이언트와 서버 상태가 다른 경우 그에 맞게 다시 되돌아가는 현상이 생길 수 있습니다.</p>
<p><img decoding="async" loading="lazy" alt="server-authoritative-overwatch-tracer-server-stunned" src="/assets/images/server-authoritative-overwatch-tracer-server-stunned-6eb6c3accece4cfa1d725f25150038d7.png" width="1500" height="902" class="img_ev3q"></p>
<p>출처: <a href="https://youtu.be/W3aieHjyNvw" target="_blank" rel="noopener noreferrer">Overwatch Gameplay Architecture and Netcode</a></p>
<p>게임 오버워치에서 &#x27;트레이서&#x27; 라는 캐릭터가 클라이언트에서는 움직이고 있다가 다른 플레이어의 공격으로 인해 기절한 상황입니다.
서버에서 기절 상태를 전송받기 전까지는 클라이언트는 계속 이동상태를 보여줍니다.</p>
<p><img decoding="async" loading="lazy" alt="server-authoritative-overwatch-tracer-client-stunned" src="/assets/images/server-authoritative-overwatch-tracer-client-stunned-1769c1ab27d4781aaef5fae798bafefc.png" width="1500" height="902" class="img_ev3q"></p>
<p>출처: <a href="https://youtu.be/W3aieHjyNvw" target="_blank" rel="noopener noreferrer">Overwatch Gameplay Architecture and Netcode</a></p>
<p>서버에서 기절 상태를 받게 되면 그 시점부터 일정 시간 동안 클라이언트에서 기절 상태를 보여줍니다.</p>
<p><img decoding="async" loading="lazy" alt="server-authoritative-overwatch-tracer-client-stunned-finished" src="/assets/images/server-authoritative-overwatch-tracer-client-stunned-finished-94333dbd6c224826e836ca20496fa5b6.png" width="1500" height="902" class="img_ev3q"></p>
<p>출처: <a href="https://youtu.be/W3aieHjyNvw" target="_blank" rel="noopener noreferrer">Overwatch Gameplay Architecture and Netcode</a></p>
<p>서버에서 받은 정보를 기반으로 기절 상태가 언제 끝나는지 클라이언트가 알기 때문에 기절 상태가 끝나면 원래 상태로 복구합니다.
위 이미지에서는 30-32 frame 이 클라이언트에서 기절 시간 후에 원래 상태로 복구하는 것을 나타냅니다.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="time-synchronization">Time Synchronization<a href="#time-synchronization" class="hash-link" aria-label="Direct link to Time Synchronization" title="Direct link to Time Synchronization">​</a></h3>
<p>먼저 서버와 다수의 클라이언트에서 사용하는 시간 정보를 맞춰야 클라이언트에서 발생하는 이벤트 순서를 정할 수 있습니다.
이벤트 순서에 따라 그 이후에 이루어지는 상황이 변할 수 있으니 시간 동기화는 굉장히 중요합니다.
머신에서 제공하는 타임스탬프 값을 사용하여 이벤트가 발생한 시점 정보를 공유할 수 있는데, 문제는 머신마다 시간 정보에 미세한 차이가 있을 수 있습니다.
그래서 서버에서 시간을 결정하고 클라이언트에게는 현재 시간을 파악하는 API 를 제공합니다.</p>
<p><img decoding="async" loading="lazy" alt="time-synchronization-estimation" src="/assets/images/time-synchronization-estimation-d2ff50d584304c8f2875bc4e93f883f3.png" width="539" height="357" class="img_ev3q"></p>
<p>출처: <a href="https://blog.naver.com/linegamedev/221060368580" target="_blank" rel="noopener noreferrer">멀티플레이 게임의 동기화 기법 시리즈 1편: 시간 동기화</a></p>
<p>위 그림처럼 클라이언트가 현재 시간을 알려달라는 API 를 호출 - 서버는 클라이언트 요청을 받아 현재 시간을 반환 - 반환한 값이 클라이언트까지 돌아오게 됩니다.
실제로 서버가 응답을 받았을 때에 대한 시간을 클라이언트가 알기 어렵기 때문에 통계적으로 추정합니다.
간단한 방법으로, 여러 번 API 를 호출하여 평균과 표준편차를 구해 구간을 벗어나는 데이터는 전부 이상치로 간주할 수도 있습니다.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="tick-rate">Tick Rate<a href="#tick-rate" class="hash-link" aria-label="Direct link to Tick Rate" title="Direct link to Tick Rate">​</a></h3>
<p>서버에서는 클라이언트의 입력을 받아 시뮬레이션 한 결과값을 클라이언트에 알려주는데 이러한 과정을 얼마나 자주할지도 게임을 플레이하는 플레이어한테 많은 영향을 끼칩니다.
자주하게 되면 더 정확한 판정, 되감기에도 유리하지만 높은 네트워크 대역과 CPU 를 요구하기 때문에 회사에서는 큰 비용을 부담해야 합니다.
오버워치는 Broadcast 비율을 20Hz 정도로 서버에서 1번 업데이트가 클라이언트에서는 3-4 frame 을 차지합니다.
1 frmae 은 16ms 정도로 서버의 약 48ms 늦은 상태를 보고 있다는 뜻입니다.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="area-of-interest">Area of Interest<a href="#area-of-interest" class="hash-link" aria-label="Direct link to Area of Interest" title="Direct link to Area of Interest">​</a></h3>
<p>서버는 클라이언트에게 시뮬레이션 한 결과값을 알려주는데 Tick Rate 는 얼마나 자주할건지에 대한 얘기라면 Area of Interest 는 어디까지 알려줘야하는가 입니다.
범위가 넓으면 패킷 처리량이 많아지고 보안에 좋지 않습니다.
배틀그라운드의 경우 원거리 저격에 떄문에 멀리 있는 적 정보까지 동기화 해야 하는데, 클라이언트 메모리 정보만으로 많은 정보들을 확보할 수 있어 다양한 핵이 나올 수 있습니다.
범위가 좁다면 갑자기 다른 플레이어가 튀어 나오는 경험 등 플레이어에게 안좋은 경험이기 때문에 개발사는 범위를 잘 고려해야 합니다.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="snapshot-and-delta">Snapshot and Delta<a href="#snapshot-and-delta" class="hash-link" aria-label="Direct link to Snapshot and Delta" title="Direct link to Snapshot and Delta">​</a></h3>
<p>클라이언트가 입력을 보내면 서버가 시뮬레이션을 진행한 후 스냅샷을 배포하면 클라이언트들은 그 스냅샷을 적용합니다.
모든 객체의 상태를 동기화하기 때문에 객체가 늘어나면 스냅샷 크기가 커집니다.
스냅샷 크기를 조절하기 위해 수신자별 우선순위가 높은 변경점을 우선해서 발송하거나 발송빈도를 높여 스냅샷 크기 자체를 줄일 수도 있습니다.</p>
<h1>Synchronization Details</h1>
<p><img decoding="async" loading="lazy" alt="client-server-request-response-delay" src="/assets/images/client-server-request-response-delay-bc5d964d9fcac730df8b991546f35092.png" width="430" height="249" class="img_ev3q"></p>
<p>출처: <a href="https://www.gabrielgambetta.com/client-server-game-architecture.html" target="_blank" rel="noopener noreferrer">Fast-Paced Multiplayer (Part I): Client-Server Game Architecture</a></p>
<p>클라이언트와 서버 통신으로 인해 실제로 플레이어가 요청한 입력은 일정 시간 후에 처리됩니다.</p>
<p><img decoding="async" loading="lazy" alt="client-server-request-response-animation-after-delay" src="/assets/images/client-server-request-response-animation-after-delay-a0fda3bb3f1c840bd1907fae1ca8b381.png" width="484" height="383" class="img_ev3q"></p>
<p>출처: <a href="https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html" target="_blank" rel="noopener noreferrer">Fast-Paced Multiplayer (Part II): Client-Side Prediction and Server Reconciliation</a></p>
<p>일정 시간 후에 동작하는 움직임은 플레이어들에게 그리 좋지 않은 경험입니다.</p>
<p><img decoding="async" loading="lazy" alt="client-server-request-response-animation-delay-other-players" src="/assets/images/client-server-request-response-delay-other-players-0c1d581f42527aef53b57388445c44b4.png" width="738" height="452" class="img_ev3q"></p>
<p>출처: <a href="https://www.gabrielgambetta.com/entity-interpolation.html" target="_blank" rel="noopener noreferrer">Fast-Paced Multiplayer (Part III): Entity Interpolation</a></p>
<p>변경된 상태를 서버에서 다른 클라이언트까지 보내는 데 추가로 시간이 들기 때문에 실제로 플레이어들은 일관성이 맞지 않는 경험을 자주 할 수 있습니다.</p>
<p>실제로 우리가 게임할 때 동시에 일어나는 것처럼 느끼는데 이러한 제약을 어떻게 극복하고 있는지를 찾아봤습니다.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="prediction-and-reconciliation">Prediction and Reconciliation<a href="#prediction-and-reconciliation" class="hash-link" aria-label="Direct link to Prediction and Reconciliation" title="Direct link to Prediction and Reconciliation">​</a></h2>
<p><img decoding="async" loading="lazy" alt="prediction-reconciliation-move-first-before-response" src="/assets/images/prediction-reconciliation-move-first-before-response-a3436a3e830547beaf2e1f4831e4b8ab.png" width="484" height="452" class="img_ev3q"></p>
<p>출처: <a href="https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html" target="_blank" rel="noopener noreferrer">Fast-Paced Multiplayer (Part II): Client-Side Prediction and Server Reconciliation</a></p>
<p>간단한 해결책으로 서버 응답을 기다리지 않고 먼저 움직이는 것입니다.
근데 그렇게 하면 이후 서버에서 응답이 왔을 때 다시 전위치로 돌아갔다가 제위치로 돌아오게 됩니다.</p>
<p><img decoding="async" loading="lazy" alt="prediction-reconciliation-move-first-reconciliation" src="/assets/images/prediction-reconciliation-move-first-reconciliation-7014f4e18c9ecde99af90e4ed39bbb04.png" width="543" height="452" class="img_ev3q"></p>
<p>출처: <a href="https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html" target="_blank" rel="noopener noreferrer">Fast-Paced Multiplayer (Part II): Client-Side Prediction and Server Reconciliation</a></p>
<p>위 문제를 해결하기 위해 클라이언트는 입력 요청들을 저장해놓고 서버에서 오는 응답을 받을 때 이전 요청들이 처리되었는지 파악합니다.
처리 되었으면 저장된 입력 요청을 버리고 또 다시 오는 응답들을 저장한 입력과 비교해가면서 적용해갈 수 있습니다.</p>
<p><a href="https://www.gabrielgambetta.com/client-side-prediction-live-demo.html" target="_blank" rel="noopener noreferrer">Fast-Paced Multiplayer: Sample Code and Live Demo</a> 를 들어가서
Prediction(서버 응답이 오기 전에 미리 움직이기) 만 키면 먼저 움직였다가 돌아오는 걸 볼 수 있습니다.
여기서 Reconciliation(요청을 저장하고 서버에서 온 응답을 처리해가면서 적용) 을 키면 원래 자리로 돌아가지 않고 부드럽게 반영되는 걸 볼 수 있습니다.</p>
<p><img decoding="async" loading="lazy" alt="client-server-request-response-delay-other-players" src="/assets/images/client-server-request-response-delay-other-players-0c1d581f42527aef53b57388445c44b4.png" width="738" height="452" class="img_ev3q"></p>
<p>출처: <a href="https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html" target="_blank" rel="noopener noreferrer">Fast-Paced Multiplayer (Part II): Client-Side Prediction and Server Reconciliation</a></p>
<p>내가 움직이는 모습을 부드럽게 하는 건 어느 정도 처리한 것 같은데 다른 플레이어들과의 상황은 어떻게 처리할 수 있을까요?</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="dead-reckoning">Dead Reckoning<a href="#dead-reckoning" class="hash-link" aria-label="Direct link to Dead Reckoning" title="Direct link to Dead Reckoning">​</a></h2>
<p><img decoding="async" loading="lazy" alt="server-response-interpolated-from-past-positions" src="/assets/images/server-response-interpolated-from-past-positions-453947fc75ceefa8920061fc3b1e0990.png" width="617" height="512" class="img_ev3q"></p>
<p>출처: <a href="https://www.gabrielgambetta.com/entity-interpolation.html" target="_blank" rel="noopener noreferrer">Fast-Paced Multiplayer (Part III): Entity Interpolation</a></p>
<p>Dead Reckoning(DR)은 &#x27;추측 항법&#x27; 으로 쓰이기도 하는데 거리 및 방향을 계산하여 위치를 추적하는 기술입니다.
게임에서 Dead Reckoning 은 캐릭터의 이동경로를 예측하는 방법이라고 할 수 있습니다.
단순히 패킷에 좌표만 담는 게 아니라 속도, 가속도를 담아 전달하면 다른 클라이언트에서는 마지막으로 확인된 패킷의 정보를 통해 현재 위치를 유추할 수 있습니다.
즉, 위치, 향하는 방향 그리고 속도를 알고 있고 현재가 그 시점으로부터 어느 정도 시간이 흘렀는지를 알고 있다면 현재 위치를 계산할 수 있습니다.</p>
<p><img decoding="async" loading="lazy" alt="interpolation-extrapolation-cartrider" src="/assets/images/interpolation-extrapolation-cartrider-0cf47812f9ec637b861172e9a7c79f27.png" width="2000" height="882" class="img_ev3q"></p>
<p>출처: <a href="https://youtu.be/r4ZaolMQOzE" target="_blank" rel="noopener noreferrer">〈카트라이더〉 0.001초 차이의 승부 - 300km/h 물체의 네트워크 동기화 모델 구현기</a></p>
<p>카트라이더 같은 차량 경주 게임에서는 이러한 요소들이 굉장히 중요합니다.
순위를 가르는 경쟁에서 실제 서버에서는 내 위치가 상대방 보다 뒤에 있는데 앞에 있다고 보이면 안되니까요.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="interpoliation-and-extrapolation">Interpoliation and Extrapolation<a href="#interpoliation-and-extrapolation" class="hash-link" aria-label="Direct link to Interpoliation and Extrapolation" title="Direct link to Interpoliation and Extrapolation">​</a></h3>
<iframe width="560" height="315" src="https://www.youtube.com/embed/r4ZaolMQOzE?start=650&amp;end=725" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"></iframe>
<p>Interpolation 은 0 과 1 값이 있을 때 0 과 1 사잇 값을 유추하는 거라면, Extrapolation Range 를 넘어선 2, 3을 유추하는 과정입니다.
패킷을 보낸 시각, 카트의 위치, 카트의 선형 속도, 각속도 등을 이용하여 상대방의 위치를 유추합니다.
클라이언트 간 시간을 맞추기 위해 서버 시간을 이용, 서버는 클라이언트에 현재 시간을 보냅니다.
클라이언트 시계와 서버 시계를 비교하여 델타를 구해 서버의 시간을 유추하고 패킷에 담습니다.</p>
<p><img decoding="async" loading="lazy" alt="extrapolation-cartrider" src="/assets/images/extrapolation-cartrider-dcce3e6cd7a5929eac5e2abdf5cdb4f2.png" width="2206" height="852" class="img_ev3q"></p>
<p>출처: <a href="https://youtu.be/r4ZaolMQOzE" target="_blank" rel="noopener noreferrer">〈카트라이더〉 0.001초 차이의 승부 - 300km/h 물체의 네트워크 동기화 모델 구현기</a></p>
<p>현재 위츠는 이전 프레임에서 계산된 위치입니다.
패킷을 받은 후에 속도와 시간을 이용하여 다음 위치를 계산, 여기서 Interpolation 한번 더해서 새로운 위치를 계산합니다. 각도도 같은 방법으로 계산합니다.
구체적인 내용은 <a href="https://youtu.be/r4ZaolMQOzE" target="_blank" rel="noopener noreferrer">영상</a>을 참고해주세요.</p>
<p>위와 같은 계산을 이용하면 20ms 레이턴시를 가질 때 영상입니다.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/r4ZaolMQOzE?start=840&amp;end=869" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"></iframe>
<p>200ms 레이턴시를 가질 때 영상입니다.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/r4ZaolMQOzE?start=880&amp;end=920" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"></iframe>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="remove-animations">Remove Animations<a href="#remove-animations" class="hash-link" aria-label="Direct link to Remove Animations" title="Direct link to Remove Animations">​</a></h2>
<p><img decoding="async" loading="lazy" alt="remove-animations-attacks-at-diffrent-times-before" src="/assets/images/remove-animations-attacks-at-diffrent-times-before-d6260396c5a05e4d4be37d7896300ceb.png" width="2040" height="1288" class="img_ev3q"></p>
<p>출처: <a href="https://noti.st/eiaserinnys/jCpSbp" target="_blank" rel="noopener noreferrer">네트웍 동기화 개론과 고급 동기화 기법</a></p>
<p>상대방은 타격 요청을 하고 바로 애니메이션이 시작하는데 서버에서 상대방의 타격 요청을 알려줬을 때는 상대방 클라이언트에서 이미 타격 애니메이션이 꽤나 진행된 상태일 것입니다.
실제로 동시에 타격판정이 일어나지 않아 보일 수 있다는 것이죠.</p>
<p><img decoding="async" loading="lazy" alt="remove-animations-attacks-at-diffrent-times-after" src="/assets/images/remove-animations-attacks-at-diffrent-times-after-3cbc614b14814ed82c39fdfad162f827.png" width="1404" height="868" class="img_ev3q"></p>
<p>출처: <a href="https://noti.st/eiaserinnys/jCpSbp" target="_blank" rel="noopener noreferrer">네트웍 동기화 개론과 고급 동기화 기법</a></p>
<p>동시에 타격이 일어나게 하기 위해 중간에 애니메이션을 삭제하거나 빠르게 진행할 수 있습니다.</p>
<p>| 처리하지 않았을 때 | 동기화 처리를 했을 때 |
| <img decoding="async" loading="lazy" alt="remove-animations-non-converging-prediction" src="/assets/images/remove-animations-non-converging-prediction-e080b56d80191f3c2db8f0b51ae22b7e.png" width="964" height="782" class="img_ev3q"> | <img decoding="async" loading="lazy" alt="remove-animations-converging-prediction" src="/assets/images/remove-animations-converging-prediction-e2e3060da6cd7273315ff9c2066d325f.png" width="1344" height="644" class="img_ev3q"> |</p>
<video width="80%" controls=""><source src="/assets/medias/remove-animations-pico-tanks-bec29ae87d1824975ca2140604600f97.mp4" type="video/mp4"></video>
<p>출처: <a href="https://twitter.com/PickTanks/status/1097623864966819840" target="_blank" rel="noopener noreferrer">PickoTanks Twitter</a></p>
<p>위 영상 약 10초 부분에서 파란 탱크의 미사일이 갑자기 중간에 생기는 것을 볼 수 있습니다.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="hit-registration-and-lag-compensation">Hit Registration and Lag Compensation<a href="#hit-registration-and-lag-compensation" class="hash-link" aria-label="Direct link to Hit Registration and Lag Compensation" title="Direct link to Hit Registration and Lag Compensation">​</a></h2>
<p>실제 타격 피해에 대해서는 클라이언트에서 처리하면 많은 부정행위 떄문에 플레이어들이 떠날 수 있습니다.
그래서 서버에서 클라이언트 상태, 지연시간 등을 고려, 서버에서 정보를 재구성하고 타격 처리를 진행합니다.</p>
<p><img decoding="async" loading="lazy" alt="hit-registration-boundary-overwatch-example" src="/assets/images/hit-registration-boundary-overwatch-example-27864f5403272bb3ae8b8d6c09e9d22e.png" width="1920" height="1072" class="img_ev3q"></p>
<p>출처: <a href="https://youtu.be/W3aieHjyNvw" target="_blank" rel="noopener noreferrer">Overwatch Gameplay Architecture and Netcode</a></p>
<p>오버워치에서는 타격 판정을 위해 객체에 대한 Bounding Volume 을 계산합니다.
해당 객체가 0.5초 정도 사이에 움직일 수 있는 영역을 계산하여 영역에 총알이 들어 갔을 때 해당 객체의 정보를 재구성하는지 판단합니다.
위 이미지에서 총을 쐈을 때 라인하르트(오른쪽에 방패들고 있는 애) 에 대한 정보를 재구성하지 않습니다.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/W3aieHjyNvw?start=2270&amp;end=2305" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"></iframe>
<p>오버워치에서 타격 판정을 위해 어떻게 계산하는지 시각적으로 보여주는 영상입니다.</p>
<p>아래 2개의 영상은 클라이언트에서는 타격했다고 판정해서 애니메이션을 보여주지만 실제로 서버가 재구성했을 때는 타격이 아니라고 판정하는 경우입니다.</p>
<ul>
<li>Overwatch: Ana and Mei</li>
</ul>
<p>총을 발포했지만 메이의 스킬로 인해 발포자의 위치가 바뀌어 실제로 타격이 일어나지 않았다 고 판단한 경우입니다.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/W3aieHjyNvw?start=2440&amp;end=2500" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"></iframe>
<ul>
<li>Overwatch: Hanzo and Reaper</li>
</ul>
<p>한조가 화살을 쏴서 타격 애니메이션이 발동했지만 리퍼의 스킬로 인해 실제로 맞지 않았다고 판단한 경우입니다. 실제로 피해를 입었다면 상단에 체력바가 뜹니다.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/W3aieHjyNvw?start=2500&amp;end=2535" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"></iframe>
<p><img decoding="async" loading="lazy" alt="lag-compensation" src="/assets/images/lag-compensation-0b4058172b455edc062c9af5e8f58b71.png" width="690" height="372" class="img_ev3q"></p>
<p>출처: <a href="https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking#Lag_compensation" target="_blank" rel="noopener noreferrer">ValveSofteware Wiki - LagCompensation</a></p>
<p>지연에 대해서 서버에서 위치를 보정하는 로직을 시각화한 예입니다.
붉은색 박스가 총 쏘는 입장에서 캐릭터 위치, 파란색 박스가 서버에서는 실제 캐릭터 위치를 100ms 뒤로 이동시킨 위치입니다.
타격이 파란색 박스 어느정도 겹치면 히트 판정하는 식입니다.</p>
<p><img decoding="async" loading="lazy" alt="lag-compenstion-graph-shooting" src="/assets/images/lag-compenstion-graph-shooting-da894b1a8e62c0c2e8e0030f6ce7088b.png" width="1826" height="1058" class="img_ev3q"></p>
<p>출처: <a href="https://youtu.be/j3eQNm-Wk04" target="_blank" rel="noopener noreferrer">[NDC] CAP 이론을 통한 네트워크 동기화 기법</a></p>
<p>클라이언트는 과거 서버의 상태를 보여주기 때문에 타격이 실행된 시점과 현 시점의 상대방의 위치는 다를 수 있습니다.</p>
<p><img decoding="async" loading="lazy" alt="lag-compenstion-graph-shooting-rewind" src="/assets/images/lag-compenstion-graph-shooting-rewind-ca6e0b556941b55cf2927321fa71d139.png" width="1826" height="1058" class="img_ev3q"></p>
<p>출처: <a href="https://youtu.be/j3eQNm-Wk04" target="_blank" rel="noopener noreferrer">[NDC] CAP 이론을 통한 네트워크 동기화 기법</a></p>
<p>서버는 클라이언트의 지연을 고려해서 클라이언트가 보던 과거의 시점으로 상황을 돌려 판정합니다.</p>
<ol>
<li>클라이언트가 입력을 받아 시뮬레이션도 처리. 결과를 서버에 전달.</li>
<li>서버가 해당 패킷을 받으면 클라이언트의 입력 처리 시점으로 되돌린다. 클라이언트에서 보내준 결과 = 서버에서 시뮬레이션한 결과가 같으면 OK, 다르면 동기화 깨졌다고 클라이언트에 알려준다.</li>
<li>서버에서 처리한 결과를 클라이언트에서 보정.</li>
</ol>
<p>재보정 로직은 FPS 게임에서 이미 많이 쓰이고 있습니다.
리그오브레전드에서도 일부 적용되어 있는 걸 볼 수 있는데, 게임하는 도중 랜선을 뽑아보면 틱당 골드가 증가하다가 1초 정도 지나면 멈추거나 롤백되는 걸 볼 수 있다고 합니다.
위 재보정으로 피격자가 엄폐물 뒤로 숨었는데 피격될 수 있기 때문에 플레이어의 불쾌감을 어느 정도 감안하고 재구성합니다.
일반적으로 FPS 는 공격의 횟수가 피격의 횟수보다 절대적으로 많기 때문에, 현대 FPS 게임은 총 쏘는 사람 입장을 더 쾌적하게 하는 것을 주로 선택한다고 합니다.
게임 필드 전체를 되감기 하는 것이 아니라 관련 있는 플레이어들만 되감습니다.
되감기를 위해 상태를 어느 정도 길이로 저장할거냐에 대한 문제도 있습니다. 서버 - 클라이언트 간 최대 레이턴시 안에서 결정할 수 있습니다.</p>
<h1>Closing</h1>
<p>게임 개발에서 서버 - 클라이언트 간의 동기화를 위한 다양한 기술들을 알아봤습니다.
위에 언급한 이슈 외에도 다양한 이슈가 있습니다.
스타크래프트와 같이 클라이언트에서 이벤트를 시뮬레이션하는 경우 랜덤의 요소가 존재한다면 문제가 될 수 있습니다.
예를 들어 마린 데미지가 6 - 10 인데 히드라의 피가 8 남았다고 했을 때, 어떤 클라이언트에서는 죽고 어떤 클라이언트에서는 안죽는 상황이 발생할 수 있습니다.
이런 경우 동기화가 되는 서버 프레임을 Seed 로 써서 같은 난수 값이 나오게 하여 같은 결과를 얻게 만들 수 있습니다.
또한 같은 물리 계산식이라도 머신마다 부동소수점이 달라질 수 있습니다. 최적화 방식이 컴파일러마다 다르고 CPU 마다 다르기 때문에 크로스 플랫폼 멀티플레이 게임 제작 시 주의 필요가 필요합니다.</p>
<h1>Reference</h1>
<ul>
<li><a href="https://www.gabrielgambetta.com/client-server-game-architecture.html" target="_blank" rel="noopener noreferrer">Fast-Paced Multiplayer Series</a></li>
<li><a href="https://noti.st/eiaserinnys/jCpSbp" target="_blank" rel="noopener noreferrer">네트웍 동기화 개론과 고급 동기화 기법</a></li>
<li><a href="https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking#Lag_compensation" target="_blank" rel="noopener noreferrer">ValveSofteware Wiki - LagCompensation</a></li>
<li><a href="https://youtu.be/r4ZaolMQOzE" target="_blank" rel="noopener noreferrer">[NDC] 〈카트라이더〉 0.001초 차이의 승부 - 300km/h 물체의 네트워크 동기화 모델 구현기</a></li>
<li><a href="https://youtu.be/j3eQNm-Wk04" target="_blank" rel="noopener noreferrer">[NDC] CAP 이론을 통한 네트워크 동기화 기법</a></li>
<li><a href="https://youtu.be/W3aieHjyNvw" target="_blank" rel="noopener noreferrer">Overwatch Gameplay Architecture and Netcode</a></li>
<li><a href="https://blog.naver.com/linegamedev/221060368580" target="_blank" rel="noopener noreferrer">멀티플레이 게임의 동기화 기법 시리즈 1편: 시간 동기화</a></li>
<li><a href="https://blog.naver.com/linegamedev/221061964789" target="_blank" rel="noopener noreferrer">멀티플레이 게임의 동기화 기법 시리즈 2편: 이벤트 동기화</a></li>
</ul></div><footer class="docusaurus-mt-lg"><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/blog/tags/game/">game</a></li><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/blog/tags/synchronization/">synchronization</a></li></ul></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/2024/06/22/lotto-bot/"><div class="pagination-nav__sublabel">Newer post</div><div class="pagination-nav__label">Auto Lotto Bot</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/2021/09/25/uilabel-alignment/"><div class="pagination-nav__sublabel">Older post</div><div class="pagination-nav__label">UILabel Alignment</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#lockstep" class="table-of-contents__link toc-highlight">Lockstep</a></li><li><a href="#authoritative-server" class="table-of-contents__link toc-highlight">Authoritative Server</a><ul><li><a href="#time-synchronization" class="table-of-contents__link toc-highlight">Time Synchronization</a></li><li><a href="#tick-rate" class="table-of-contents__link toc-highlight">Tick Rate</a></li><li><a href="#area-of-interest" class="table-of-contents__link toc-highlight">Area of Interest</a></li><li><a href="#snapshot-and-delta" class="table-of-contents__link toc-highlight">Snapshot and Delta</a></li></ul></li><li><a href="#prediction-and-reconciliation" class="table-of-contents__link toc-highlight">Prediction and Reconciliation</a></li><li><a href="#dead-reckoning" class="table-of-contents__link toc-highlight">Dead Reckoning</a><ul><li><a href="#interpoliation-and-extrapolation" class="table-of-contents__link toc-highlight">Interpoliation and Extrapolation</a></li></ul></li><li><a href="#remove-animations" class="table-of-contents__link toc-highlight">Remove Animations</a></li><li><a href="#hit-registration-and-lag-compensation" class="table-of-contents__link toc-highlight">Hit Registration and Lag Compensation</a></li></ul></div></div></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 yongseongkim</div></div></div></footer></div>
</body>
</html>